# 面向对象

#### 三个特征

封装,继承,多态.这个应该是人人皆知.有时候也会加上抽象.

#### 接口和抽象类的区别
| 比较点       | 抽象类                                                       | 接口                                                       |
| ------------ | ------------------------------------------------------------ | ---------------------------------------------------------- |
| 默认方法     | 抽象类可以有默认的方法实现                                   | java 8之前,接口中不存在方法的实现                          |
| 实现方式     | 子类使用extends关键字来继承抽象类.如果子类不是抽象类,子类需要提供抽象类中所声明方法的实现 | 子类使用implements来实现接口,需要提供接口中所有声明的实现. |
| 构造器       | 抽象类中可以有构造器，不能实现，被子类调用                   | 接口中无                                                   |
| 和正常类区别 | 抽象类不能被实例化                                           | 接口则是完全不同的类型                                     |
| 访问修饰符   | 抽象方法可以有public,protected和default等修饰                | 接口默认是public,不能使用其他修饰符                        |
| 多继承       | 一个子类只能存在一个父类                                     | 一个子类可以存在多个接口                                   |
| 添加新方法   | 抽象类中添加新方法,可以提供默认的实现,因此可以不修改子类现有的代码 | 如果往接口中添加新方法,则子类中需要实现该方法              |

#### 父类的静态方法能否被子类重写?

不能.重写只适用于实例方法,不能用于静态方法,而子类当中含有和父类相同签名的静态方法,我们一般称之为隐藏.

#### 静态变量和实例变量

静态变量存储在方法区,属于类所有.实例变量存储在堆当中,其引用存在当前线程栈.需要注意的是从JDK1.8开始用于实现方法区的PermSpace被MetaSpace取代了.

#### java 创建对象的几种方式

java中提供了以下四种创建对象的方式:

- new创建新对象
- 通过反射机制
- 采用clone机制
- 通过序列化机制

前两者都需要显式地调用构造方法. 对于clone机制,需要注意浅拷贝和深拷贝的区别,对于序列化机制需要明确其实现原理,在java中序列化可以通过实现Externalizable或者Serializable来实现.

#### switch

在JDK 1.7之前,switch只能支持byte,short,char,int或者其对应的包装类以及Enum类型.从JDK 1.7之后switch开始支持String类型.但到目前为止,switch都不支持long类型.

#### `==`和`eqauls()`

- `==`是运算符,用于比较两个变量是否相等,对于基本类型而言比较的是变量的值,对于对象类型而言比较的是对象的地址.

- `equals()`是Object类的方法,用于比较两个对象内容是否相等

equals（）重写原则：

- 对称性。  x.equals(y)=y.equals(x)
- 自反性。  x.equals(x)=true
- 类推性。  x.equals(y)，y.equals(x)=x.equals(z)
- 一致性。 x,y不变永远相等

#### & 和 &&的区别

基础的概念不能弄混:&是位操作,&&是逻辑运算符

&&（短路）只要一个不成立就不会另一个比较，而&两边都要比较。

#### 内部类

1. **成员内部类**

   - 当内部类访问外部类时，可以不受访问控制符的影响，直接访问属性与方法
   - 当外部类变量与方法和内部类同名，内部类默认访问自己的成员变量或方法，引用外部变量使用时加类名.this：类名.this.变量名、类名.this.方法名（）
   - 在其他类创建一类中的内部类：内部类 对象名 = new 外部类对象( ).new 内部类( )
   - 外部类不能直接使用内部类的成员和方法,可先创建内部类的对象，然后通过内部类的对象来访问其成员变量和方法。

2. **静态内部类**

   - 静态内部类不能直接访问外部类的非静态成员，但可以通过 new 外部类().成员 的方式访问
   - 外部类的静态成员与内部类的成员名称相同，可通过“类名.静态成员”访问外部类的静态成员
   - 创建静态内部类的对象时，不需要通过外部类的对象，可以直接创建 内部类 对象名= new 内部类();

3. **方法内部类**

   - 在类的方法中定义，只能在同一个作用域使用，不存在外部可见性
   - 没有访问修饰符，但可以使用final 或 abstract修饰。
   - 不能在方法内部类中创建可变的局部变量。
   - 可以访问外围类的成员变量。如果是static方法，则只能访问static修饰的成员变量。

4. **匿名内部类**　

   - 使用匿名内部类时，我们必须是继承一个类或者实现一个接口，但是两者不可兼得，同时也只能继承一个类或者实现一个接口。
   - 匿名内部类中是不能定义构造函数的。
   - 匿名内部类中不能存在任何的静态成员变量和静态方法。
   - 匿名内部类为局部内部类（即方法内部类），所以局部内部类的所有限制同样对匿名内部类生效。
   - 匿名内部类不能是抽象的，它必须要实现继承的类或者实现的接口的所有抽象方法。
   - 当所在的方法的形参需要被内部类里面使用时，该形参必须为final。
   - 可以写代码块，初始化匿名内部类
   - 匿名内部类可以很方便的定义回调。
   - 使用内部类可以非常方便的编写事件驱动程序。

   **好处**

   1. 内部类提供了更好的封装，可以把内部类隐藏在外部类之内，不允许同一个包中的其他类访问该类。
   2. 内部类的方法可以直接访问外部类的所有数据，包括私有的数据。
   3. 内部类所实现的功能使用外部类同样可以实现，只是有时使用内部类更方便。

#### 深拷贝和浅拷贝

- 浅拷贝:被复制对象的所有变量都含有与原来的对象相同的值,而所有的对其他对象的引用仍然指向原来的对象.换言之,浅拷贝仅仅复制所考虑的对象,而不复制它所引用的对象.
- 深拷贝:被复制对象的所有变量都含有与原来的对象相同的值.而那些引用其他对象的变量将指向被复制过的新对象.而不再是原有的那些被引用的对象.换言之.深拷贝把要复制的对象所引用的对象都复制了一遍.

#### final

- 被final修饰的类不可以被继承
- 被final修饰的方法不可以被重写
- 被final修饰的变量不可以被改变.如果修饰引用,那么表示引用不可变,引用指向的内容可变.
- 被final修饰的方法,JVM会尝试将其内联,以提高运行效率
- 被final修饰的常量,在编译阶段会存入常量池中.

#### String,StringBuffer和StringBuilder

String是字符串常量,final修饰;StringBuffer字符串变量(线程安全);StringBuilder 字符串变量(线程不安全).此外StringBuilder和StringBuffer实现原理一样,都是基于数组扩容来实现的.

String和StringBuffer主要区别是性能:String是不可变对象,每次对String类型进行操作都等同于产生了一个新的String对象,然后指向新的String对象.所以尽量不要对String进行大量的拼接操作,否则会产生很多临时对象,导致GC开始工作,影响系统性能.

StringBuffer是对象本身操作,而不是产生新的对象,因此在有大量拼接的情况下,我们建议使用StringBuffer(线程安全).

#### a=a+b与a+=b有什么区别

`+=`操作符会进行隐式自动类型转换,此处a+=b隐式的将加操作的结果类型强制转换为持有结果的类型,而a=a+b则不会自动进行类型转换.如：

```
byte a = 127;
byte b = 127;
b = a + b; // 报编译错误:cannot convert from int to byte
b += a; 
```

+=操作符会对右边的表达式结果强转匹配左边的数据类型

#### 了解泛型么?简述泛型的上界和下界?

有时候希望传入的类型有一个指定的范围，从而可以进行一些特定的操作,这时候就需要通配符了?在Java中常见的通配符主要有以下几种:

- <?>: 无限制通配符
- <? extends E>: extends 关键字声明了类型的上界,表示参数化的类型可能是所指定的类型,或者是此类型的子类
- <? super E>: super关键字声明了类型的下界,表示参数化的类型可能是指定的类型,或者是此类型的父类

它们的目的都是为了使方法接口更为灵活,可以接受更为广泛的类型.

- < ? extends E>: 用于灵活读取，使得方法可以读取 E 或 E 的任意子类型的容器对象。
- < ? super E>: 用于灵活写入或比较,使得对象可以写入父类型的容器,使得父类型的比较方法可以应用于子类对象。

#### 强引用、软引用、弱引用、虚引用

|          |      强引用      |                          软引用                          |                            弱引用                            |                          虚引用                          |
| -------- | :--------------: | :------------------------------------------------------: | :----------------------------------------------------------: | :------------------------------------------------------: |
| 创建方式 |     new（）      |       SoftReference soft=new SoftReference(对象);        |         WeakReference weak=new WeakReference(对象);          |  PhantomReference phantom=new  PhantomReference(对象)；  |
| 回收情况 | 宁愿报错也不回收 | 在内存充足的情况下它不会被GC，但是在内存不足时可能会被GC | 弱引用存活的周期会更短，只要GC执行了，那么被弱引用关联的对象就可能会被回收 | 对象被回收跟它没啥关系。它引用的对象可以在任何时候被回收 |

#### for 、foreach、stream、迭代器

##### 关于遍历的选取 for 、foreach、stream

​		数据量低的时候 for最快；数据量越大都差不多；考虑并行的话stream并行流最快；

##### 关于边遍历边删除  for 、foreach、迭代器

不能使用foreach，foreach使用的Iterator ，hasnest（）和next（），其中next（）会检查modCount和expectedModCount();而foreach调用的list，remove会使modCount++，不等然后下次next（）报错。而迭代器的的remove会让expectModCount=modCount。

	1. 使用Iterator的remove()方法
 	2. 使用for循环正序遍历
 	3. 使用for循环倒序遍历

for循环是使用下标来查询不会调用next（），所以正序倒序都行，不过移除之后会后面往前缩一位，所以移除之后，正序i=i-1;倒序不用；