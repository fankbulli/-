# Mysql基础

### **Mysql中有哪几种锁**

1.表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低。

2.行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。

3.页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。

### **Mysql中有哪些不同的表格**

MyISAM、Heap、Merge、INNODB、ISAM

### MyIsam和InnoDb的区别

|          | MyIsam                                                       | InnoDb                                                       |
| -------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 锁形态   | 表级锁，每次操作是对整个表加锁                               | 行级锁及外键约束，支持写并发                                 |
| 事务     | 不支持                                                       | 支持ACID的事务，支持事务的四种隔离级别；                     |
|          | 存储表的总行数；                                             | 不存储总行数；                                               |
| 文件空间 | 索引文件、表结构文件、数据文件；                             | 一个InnoDb引擎存储在一个文件空间（共享表空间，表大小不受操作系统控制，一个表可能分布在多个文件里），也有可能为多个（设置为独立表空，表大小受操作系统文件大小限制，一般为2G），受操作系统文件大小的限制； |
| 索引     | 非聚集索引，索引文件的数据域存储指向数据文件的指针。辅索引与主索引基本一致，但是辅索引不用保证唯一性。 | 主键索引采用聚集索引（索引的数据域存储数据文件本身），辅索引的数据域存储主键的值；因此从辅索引查找数据，需要先通过辅索引找到主键值，再访问辅索引；最好使用自增主键，防止插入数据时，为维持B+树结构，文件的大调整。 |

### 事务四种隔离级别

| 隔离级别                     | 脏读 | 不可重复读 | 幻读 |
| ---------------------------- | ---- | ---------- | ---- |
| Read uncommitted(读未提交的) | √    | √          | √    |
| Read committed (读已提交的)  | ×    | √          | √    |
| Repeatable read(可重复的)    | ×    | ×          | √    |
| Serializable(可串行化)       | ×    | ×          | ×    |

**脏读**：即一个事物读到了另一个事物（当其执行插入，更新等操作时）未提交的数据。读脏数据一般来说是不被允许的，许多数据库默认设置的隔离级别也不会是读未提交的，如oracle默认的是读已提交的，在oracle中，当前一个事物如果未提交，其DML操作，对别的事物来说是不可见的，未提交的数据，存在高速缓存区当中，只有提交了之后才会持久化。而mysql默认的数据库隔离级别是可重复读。

**不可重复读**：（在没有加锁的情况下）事物A，执行前后2次执行一条sql，发现sql的结果不同，因为B事物在A事物执行第二次查询的时候，对A的结果的某些行提交了进行了更新，或者删除，并提交了事物。导致A事物，第二次查询出的结果和第一次不一样。

**幻读：**A事物执行一条sql查询，B事物对A事物sql的相关表添加一条数据，并提交。A事物第二次查询时发现数据行增加了。由此出现了幻读，可重复读和幻读的区别在于，前者是对已存在的数据进行并发操作，后者则是新增数据对旧的结果集的影响。有时候幻读是我们需要的，有时候是不需要的，这还得看具体业务的要求。

**Serializable(可串行化)** ：严重影响数据库性能，一般不会用到。
企业中大多数都是使用Read commited来避免脏读，如果要避免不可重复读则需要加乐观锁或悲观锁来对，数据操作定制不同的策略来解决。

### 事务特性

（1）原子性：即不可分割性，事务要么全部被执行，要么就全部不被执行。

（2）一致性或可串性。事务的执行使得数据库从一种正确状态转换成另一种正确状态

（3）隔离性。在事务正确提交之前，不允许把该事务对数据的任何改变提供给任何其他事务，

（4） 持久性。事务正确提交后，其结果将永久保存在数据库中，即使在事务提交后有了其他故障，事务的处理结果也会得到保存。

### char和varchar

1.CHAR和VARCHAR类型在存储和检索方面有所不同
2.CHAR列长度固定为创建表时声明的长度，长度值范围是1到255，当CHAR值被存储时，它们被用空格填充到特定长度，检索CHAR值时需删除尾随空格。

### **myisamchk是用来做什么的？**

它用来压缩MyISAM表，这减少了磁盘或内存使用。

### **如果一个表有一列定义为TIMESTAMP，将发生什么？**

每当行被更改时，时间戳字段将获取当前时间戳。

### AUTO INCREMENT

如果分配到最后一个值，它会停止递增，任何进一步的插入都将产生错误，因为密钥已被使用。

LAST_INSERT_ID将返回由Auto_increment分配的最后一个值，并且不需要指定表名称。

### 如何在Unix和Mysql时间戳之间进行转换

**UNIX_TIMESTAMP**是从Mysql时间戳转换为Unix时间戳的命令
**FROM_UNIXTIME**是从Unix时间戳转换为Mysql时间戳的命令

### BLOB和TEXT有什么区别

BLOB是一个二进制对象，可以容纳可变数量的数据。TEXT是一个不区分大小写的BLOB。

BLOB和TEXT类型之间的唯一区别在于对BLOB值进行排序和比较时区分大小写，对TEXT值不区分大小写。

### **列的字符串类型**

1. SET
2. BLOB
3. ENUM
4. CHAR
5. TEXT

### **MySQL数据库作发布系统的存储，一天五万条以上的增量，预计运维三年,怎么优化**

a. 设计良好的数据库结构，允许部分数据冗余，尽量避免join查询，提高效率。
b. 选择合适的表字段数据类型和存储引擎，适当的添加索引。
c. mysql库主从读写分离。
d. 找规律分表，减少单表中的数据量提高查询速度。
e。添加缓存机制，比如memcached，apc等。
f. 不经常改动的页面，生成静态页面。
g. 书写高效率的SQL。比如 SELECT * FROM TABEL 改为 SELECT field_1, field_2, field_3 FROM TABLE.

### **锁的优化策略**

\1. 读写分离

\2. 分段加锁

\3. 减少锁持有的时间

\4. 多个线程尽量以相同的顺序去获取资源

不能将锁的粒度过于细化，不然可能会出现线程的加锁和释放次数过多，反而效率不如一次加一把大锁。

### **索引的底层实现原理和优化**

B+树，经过优化的B+树

主要是在所有的叶子结点中增加了指向下一个叶子节点的指针，因此InnoDB建议为大部分表使用默认自增的主键作为主索引。

**什么情况下设置了索引但无法使用**

以“%”开头的LIKE语句，模糊匹配

OR语句前后没有同时使用索引 

数据类型出现隐式转化（如varchar不加单引号的话可能会自动转换为int型）

### **实践中如何优化MySQL**

最好是按照以下顺序优化：

- SQL语句及索引的优化

- 数据库表结构的优化

- 系统配置的优化
- 硬件的优化

### **优化数据库的方法**

1. 选取最适用的字段属性，尽可能减少定义字段宽度，尽量把字段设置NOTNULL，例如’省份’、’性别’最好适用ENUM
2. 使用连接(JOIN)来代替子查询
3. 适用联合(UNION)来代替手动创建的临时表
4. 事务处理
5. 锁定表、优化事务处理
6. 适用外键，优化锁定表
7. 建立索引
8. 优化查询语句

### **简单描述mysql中，索引，主键，唯一索引，联合索引的区别，对数据库的性能有什么影响**

索引是一种特殊的文件(InnoDB数据表上的索引是表空间的一个组成部分)，它们包含着对数据表里所有记录的引用指针。

普通索引(由关键字KEY或INDEX定义的索引)的唯一任务是加快对数据的访问速度。

普通索引允许被索引的数据列包含重复的值。如果能确定某个数据列将只包含彼此各不相同的值，在为这个数据列创建索引的时候就应该用关键字UNIQUE把它定义为一个唯一索引。也就是说，唯一索引可以保证数据记录的唯一性。

主键，是一种特殊的唯一索引，在一张表中只能定义一个主键索引，主键用于唯一标识一条记录，使用关键字 PRIMARY KEY 来创建。

索引可以覆盖多个数据列，如像INDEX(columnA, columnB)索引，这就是联合索引。

索引可以极大的提高数据的查询速度，但是会降低插入、删除、更新表的速度，因为在执行这些写操作时，还要操作索引文件。

**负面影响：**
创建索引和维护索引需要耗费时间，这个时间随着数据量的增加而增加；索引需要占用物理空间，不光是表需要占用数据空间，每个索引也需要占用物理空间；当对表进行增、删、改、的时候索引也要动态维护，这样就降低了数据的维护速度。

最多16个索引；

### **SQL注入**

SQL注入产生的原因：程序开发过程中不注意规范书写sql语句和对特殊字符进行过滤，导致客户端可以通过全局变量POST和GET提交一些sql语句正常执行。

防止SQL注入的方式：
开启配置文件中的magic_quotes_gpc 和 magic_quotes_runtime设置

执行sql语句时使用addslashes进行sql语句转换

Sql语句书写尽量不要省略双引号和单引号。

过滤掉sql语句中的一些关键词：update、insert、delete、select、 * 。

提高数据库表和字段的命名技巧，对一些重要的字段根据程序的特点命名，取不易被猜到的。

### **为表中得字段选择合适得数据类型**

字段类型优先级: 整形>date,time>enum,char>varchar>blob,text
优先考虑数字类型，其次是日期或者二进制类型，最后是字符串类型，同级别得数据类型，应该优先选择占用空间小的数据类型

### 解释MySQL外连接、内连接与自连接的区别

先说什么是交叉连接: 交叉连接又叫笛卡尔积，它是指不使用任何条件，直接将一个表的所有记录和另一个表中的所有记录一一匹配。

内连接 则是只有条件的交叉连接，根据某个条件筛选出符合条件的记录，不符合条件的记录不会出现在结果集中，即内连接只连接匹配的行。
外连接 其结果集中不仅包含符合连接条件的行，而且还会包括左表、右表或两个表中
的所有数据行，这三种情况依次称之为左外连接，右外连接，和全外连接。

左外连接，也称左连接，左表为主表，左表中的所有记录都会出现在结果集中，对于那些在右表中并没有匹配的记录，仍然要显示，右边对应的那些字段值以NULL来填充。右外连接，也称右连接，右表为主表，右表中的所有记录都会出现在结果集中。左连接和右连接可以互换，MySQL目前还不支持全外连接。

### SQL语句优化分页很多怎么优化

（1）Where子句中：where表之间的连接必须写在其他Where条件之前，那些可以过滤掉最大数量记录的条件必须写在Where子句的末尾.HAVING最后。

（2）用EXISTS替代IN、用NOT EXISTS替代NOT IN。

（3） 避免在索引列上使用计算

（4）避免在索引列上使用IS NULL和IS NOT NULL

（5）对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引。

（6）应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描

（7）应尽量避免在 where 子句中对字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描

### 约束

| 约束类型： | 关键字：    | 含义：                                                       |
| ---------- | ----------- | ------------------------------------------------------------ |
| **主键**   | PRIMARY KEY | NOT NULL 和 UNIQUE 的结合。确保某列（或两个列多个列的结合）有唯一标识，有助于更容易更快速地找到表中的一个特定的记录 |
| **默认值** | DEFAULT     | 规定没有给列赋值时的默认值。                                 |
| **唯一**   | UNIQUE      | 保证某列的每行必须有唯一的值                                 |
| **外键**   | FOREIGN KEY | 保证一个表中的数据匹配另一个表中的值的参照完整性             |
| **非空**   | NOT NULL    | 指示某列不能存储 NULL 值                                     |
| **检查**   | CHECK       | 保证列中的值符合指定的条件                                   |

### 大数据分页偏移量增大如何解决

使用先使用范围查询定位 id （或者索引），然后再使用索引进行定位数据，能够提高好几倍查询速度。即先 select id，然后再 select *；

#### 使用子查询优化

这种方式先定位偏移位置的 id，而后日后查询，这种方式适用于 id 递增的状况。

#### 使用 id 限定优化

这种方式假设数据表的id是**连续递增**的，则咱们根据查询的页数和查询的记录数能够算出查询的id的范围，可使用 id between and 来查询：

#### 使用临时表优化

这种方式已经不属于查询优化，这儿附带提一下。

对于使用 id 限定优化中的问题，须要 id 是连续递增的，可是在一些场景下，好比使用历史表的时候，或者出现过数据缺失问题时，能够考虑使用临时存储的表来记录分页的id，使用分页的id来进行 in 查询。这样可以极大的提升传统的分页查询速度，尤为是数据量上千万的时候。

#### 关于数据表的id说明

通常状况下，在数据库中创建表的时候，强制为每一张表添加 id 递增字段，这样方便查询。

若是像是订单库等数据量很是庞大，通常会进行分库分表。这个时候不建议使用数据库的 id 做为惟一标识，而应该使用分布式的高并发惟一 id 生成器来生成，并在数据表中使用另外的字段来存储这个惟一标识。

使用先使用范围查询定位 id （或者索引），而后再使用索引进行定位数据，可以提升好几倍查询速度。即先 select id，而后再 select *；

### 慢sql优化

